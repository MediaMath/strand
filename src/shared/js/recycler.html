<!--
@license
Copyright (c) 2015 MediaMath Inc. All rights reserved.
This code may only be used under the BSD style license found at http://mediamath.github.io/strand/LICENSE.txt
-->
<link rel="import" href="snake.html"/>
<link rel="import" href="continuum.html"/>
<script language="javascript">
(function (scope) {

	function Fence (position, size, above, below) {
		this._placement = 0;
		this._dimension = 0;

		this._paddingAbove = 0;
		this._paddingBelow = 0;

		this._orientation = 0;

		this.reposition(+position || 0);
		this.resize(+size || 0);
		this.repad(+above || 0, +below || 0);
	}

	Fence.prototype.isReversed = function () {
		return 0|!!this._orientation;
	};

	Fence.prototype.flipOrientation = function () {
		var size = this._paddingAbove;
		this._paddingAbove = this._paddingBelow;
		this._paddingBelow = size;

		return this._orientation = 0|!this._orientation;
	};

	Fence.prototype.getPlacement = function () {
		return this._placement;
	};

	Fence.prototype.getDimension = function () {
		return this._dimension;
	};

	Fence.prototype.getLower = function () {
		return this._placement - this._paddingBelow;
	};

	Fence.prototype.getUpper = function () {
		return this._placement + this._dimension + this._paddingAbove;
	};

	Fence.prototype.reposition = function (position) {
		return this.translate((+position || 0) - (+this._placement || 0));
	};

	Fence.prototype.translate = function (change) {
		var delta = +change || 0;

		if (delta) {
			this._placement = (+this._placement || 0) + delta;
			if (delta < 0 ^ this._orientation) {
				this.flipOrientation();
			}
			return 0|true;
		} else {
			return 0|false;
		}
	};

	Fence.prototype.resize = function (size) {
		var value = +size || 0;
		if (this._dimension !== value) {
			this._dimension = value;
			return 0|true;
		} else {
			return 0|false;
		}
	};

	Fence.prototype.adjust = function (grow) {
		return this.resize((+this._dimension || 0) + (+grow || 0));
	};

	Fence.prototype.repad = function (ahead, behind) {
		return 0|this._orientation ? this._insolate(behind, ahead) : this._insolate(ahead, behind);
	};

	Fence.prototype._insolate = function (above, below) {

		var header = (+above || 0);
		var footer = (+below || 0);
		var delta = 0;

		switch (arguments.length) {
			default:
			case 2: 
				delta = delta || this._paddingBelow !== footer;
				this._paddingBelow = footer;
			case 1:
				delta = delta || this._paddingAbove !== header;
				this._paddingAbove = header;
			case 0:
		}

		return 0|!!delta;
	};



	function Placeholder (inner) {
		this._innerIndex = 0|inner;
		this._outerIndex = -1;
	}

	Placeholder.prototype.getInnerIndex = function () {
		return this._innerIndex;
	};

	Placeholder.prototype.getOuterIndex = function () {
		return this._outerIndex;
	};

	Placeholder.prototype.setOuterIndex = function (index) {
		var old = this._outerIndex;
		this._outerIndex = 0|index;
		return old;
	};



	function ContinuumInterface (continuum, firstUnavailableIndexGetter, indexChangeListener) {
		var listenerIsFunction = typeof indexChangeListener === "function";
		var getterIsFunction = typeof firstUnavailableIndexGetter === "function";

		this._continuum = continuum || null;

		this._getFirstUnavailableIndex = null;
		this._getFirstUnavailableIndex = getterIsFunction ? firstUnavailableIndexGetter : function (ideal) {
			return -1;
		};

		this._notifyIndex = null;
		this._notifyIndex = listenerIsFunction ? indexChangeListener : function (inner, young, old, recycler) {

		};
	}

	ContinuumInterface.prototype.notify = function (inner, young, old, recycler) {
		this._notifyIndex.call(recycler, inner, young, old, recycler);
	};

	ContinuumInterface.prototype.getContinuum = function () {
		return this._continuum;
	};

	ContinuumInterface.prototype.trim = function (index) {
		return this._continuum.terminate(index);
	};

	ContinuumInterface.prototype.getIndexAtElevation = function (elevation, recycler) {
		var continuum = this._continuum;
		var count = 0|continuum.getDiscreteCount();
		var position = +continuum.getElevation(count) || 0;

		if (elevation < position) {
			return this._getKnownIndexAtElevation(elevation, continuum, count, 0);
		} else {
			return this._getUnknownIndexAtElevation(elevation, continuum, count, recycler);
		}
	};

	ContinuumInterface.prototype._getKnownIndexAtElevation = function (elevation, continuum, count, start) {
		var position = 0;
		var index = 0;
		var lower = start;
		var upper = count;
		var limit = count;

		for (limit; limit; limit--) {
			index = (lower + upper) >> 1;
			position = +continuum.getElevation(index) || 0;
			if (elevation < position) {
				upper = index;
			} else if (index > lower) {
				lower = index;
			} else {
				return index;
			}
		}

		return -1;
	};

	ContinuumInterface.prototype._getUnknownIndexAtElevation = function (elevation, continuum, count, recycler) {
		var position = 0;
		var delta = 1;
		var limit = count;
		var lower = limit;
		var upper = lower;

		do {
			lower = upper;
			upper += delta;
			limit = 0|this._getFirstUnavailableIndex.call(null, upper, recycler);

			if (limit > -1 &&
				upper > limit) {
				upper = limit;
				delta = 0;
			}

			position = +continuum.getElevation(upper) || 0;

			if (elevation < position) {
				delta = 1;
				break;
			}
		} while (delta = (delta << 1) >>> 0)

		if (delta) {
			return this._getKnownIndexAtElevation(elevation, continuum, upper, lower);
		} else {
			return -1;
		}
	};

	ContinuumInterface.prototype.getDiscreteCount = function () {
		var continuum = this.getContinuum();
		return continuum.getDiscreteCount.apply(continuum, arguments);
	};

	ContinuumInterface.prototype.setHeight = function (index, height) {
		var continuum = this.getContinuum();
		return continuum.setHeight.apply(continuum, arguments);
	};

	ContinuumInterface.prototype.getHeight = function (index) {
		var continuum = this.getContinuum();
		return continuum.getHeight.apply(continuum, arguments);

	};

	ContinuumInterface.prototype.getElevation = function (index) {
		var continuum = this.getContinuum();
		return continuum.getElevation.apply(continuum, arguments);

	};

	ContinuumInterface.prototype.isElevationKnown = function (index) {
		var continuum = this.getContinuum();
		return continuum.isElevationKnown.apply(continuum, arguments);

	};

	ContinuumInterface.prototype.isHeightKnown = function (index) {
		var continuum = this.getContinuum();
		return continuum.isHeightKnown.apply(continuum, arguments);
	};



	function Solver () {

	}

	Solver.prototype.solve = function (destructive, interface, lower, upper, alpha, omega, placeholders, available, recycler) {
		var currentCount = 1 + omega - alpha;

		var deltaLower = lower - alpha;
		var deltaUpper = upper - omega;
		var deltaCount = deltaUpper - deltaLower;
		var deltaShift = 0;

		if (!destructive &&
			deltaCount < 0) {
			deltaShift = deltaCount;
			deltaCount = 0;
		}

		if (deltaLower > 0) {
			if (deltaUpper > 0) {
				if (deltaCount > 0) {
					if (currentCount > deltaLower) {
						this._windUp(interface, placeholders, deltaLower, recycler);
					} else {
						this._jump(interface, placeholders, lower, currentCount, recycler);
					}

					this._pushUp(interface, placeholders, deltaCount, available, recycler);
				} else {
					if (deltaCount < 0) {
						this._cutUp(interface, placeholders, -deltaCount, available, recycler);

						currentCount += deltaCount;
					}

					if (currentCount > deltaUpper) {
						this._windUp(interface, placeholders, deltaUpper, recycler);
					} else {
						this._jump(interface, placeholders, lower + deltaShift, currentCount, recycler);
					}
				}
			} else if (deltaCount < 0) {
				this._cutUp(interface, placeholders, deltaUpper, available, recycler);
				this._cutDown(interface, placeholders, -deltaLower, available, recycler);
			}
		} else {
			if (deltaUpper < 0) {
				if (deltaCount > 0) {
					if (currentCount > -deltaUpper) {
						this._windDown(interface, placeholders, -deltaUpper, recycler);
					} else {
						this._jump(interface, placeholders, lower, currentCount, recycler);
					}

					this._pushDown(interface, placeholders, deltaCount, available, recycler);
				} else {
					if (deltaCount < 0) {
						this._cutDown(interface, placeholders, -deltaCount, available, recycler);

						currentCount += deltaCount;
					}

					if (currentCount > -deltaLower) {
						this._windDown(interface, placeholders, -deltaLower, recycler);
					} else {
						this._jump(interface, placeholders, lower, currentCount, recycler);
					}
				}
			} else if (deltaCount > 0) {
				this._pushUp(interface, placeholders, deltaUpper, available, recycler);
				this._pushDown(interface, placeholders, -deltaLower, available, recycler);
			}
		}
	};

	Solver.prototype._claimAvailable = function (placeholders, available) {
		var any = available.getTail();

		if (any) {
			any.dropAnyway();
			return any.body;
		} else {
			return placeholders.getCount();
		}
	};

	Solver.prototype._abandonAvailable = function (index, available) {
		available.addTail().body = index;
	};

	Solver.prototype._cutUp = function (interface, placeholders, amount, available, recycler) {
		var count = 0|amount;
		var index = 0;
		var snake = placeholders.getHead();
		var p = snake.body;

		while (count-- > 0) {
			p = snake.body;
			index = p.getInnerIndex();
			snake = snake.dropTailwise();
			this._abandonAvailable(index, available);
			interface.notify(index, -1, p.getOuterIndex(), recycler);
		}
	};

	Solver.prototype._cutDown = function (interface, placeholders, amount, available, recycler) {
		var count = 0|amount;
		var index = 0;
		var snake = placeholders.getTail();
		var p = snake.body;

		while (count-- > 0) {
			p = snake.body;
			index = p.getInnerIndex();
			snake = snake.dropHeadwise();
			this._abandonAvailable(index, available);
			interface.notify(index, -1, p.getOuterIndex(), recycler);
		}
	};

	Solver.prototype._pushUp = function (interface, placeholders, amount, available, recycler) {
		var p = null;
		var snake = placeholders.getTail();
		var young = snake ? snake.body.getOuterIndex() : -1;
		var index = 0;
		var count = 0|amount;

		while (count-- > 0) {
			index = this._claimAvailable(placeholders, available);
			p = makePlaceholder(index);
			p.setOuterIndex(++young);
			placeholders.addTail().body = p;
			interface.notify(index, young, -1, recycler);
		}
	};

	Solver.prototype._pushDown = function (interface, placeholders, amount, available, recycler) {
		var p = null;
		var snake = placeholders.getHead();
		var young = snake ? snake.body.getOuterIndex() : -1;
		var index = 0;
		var count = 0|amount;

		while (count-- > 0) {
			index = this._claimAvailable(placeholders, available);
			p = makePlaceholder(index);
			p.setOuterIndex(--young);
			placeholders.addHead().body = p;
			interface.notify(index, young, -1, recycler);
		}
	};

	Solver.prototype._windUp = function (interface, placeholders, moves, recycler) {
		var p = null;
		var snake = placeholders.getHead();
		var temp = placeholders.getTail();
		var old = 0;
		var young = temp.body.getOuterIndex();
		var count = 0|moves;

		while (count-- > 0) {
			p = snake.body;
			old = p.getOuterIndex();
			p.setOuterIndex(++young);
			temp = snake.dropTailwise();
			placeholders.addTail(snake);
			snake = temp;
			interface.notify(p.getInnerIndex(), young, old, recycler);
		}
	};

	Solver.prototype._windDown = function (interface, placeholders, moves, recycler) {
		var p = null;
		var snake = placeholders.getTail();
		var temp = placeholders.getHead();
		var old = 0;
		var young = temp.body.getOuterIndex();
		var count = 0|moves;

		while (count-- > 0) {
			p = snake.body;
			old = p.getOuterIndex();
			p.setOuterIndex(--young);
			temp = snake.dropHeadwise();
			placeholders.addHead(snake);
			snake = temp;
			interface.notify(p.getInnerIndex(), young, old, recycler);
		}
	};

	Solver.prototype._jump = function (interface, placeholders, index, moves, recycler) {
		var snake = placeholders.getHead();
		var p = snake.body;
		var old = p.getOuterIndex();
		var young = 0|index;
		var count = 0|moves;

		p.setOuterIndex(index);
		snake.dropTailwise();
		placeholders.addTail(snake);
		interface.notify(p.getInnerIndex(), young, old, recycler);

		this._windUp(interface, placeholders, count - 1, recycler);
	};



	var NONDESTRUCTIVE = 0;
	var DESTRUCTIVE = 1 << 0;

	var NumberList = Snake.prototype.implementationFactory();

	function makePlaceholder(inner) {
		return new Placeholder(inner);
	}

	function provideContinuum (initialHeightGetter) {
		return new Continuum(initialHeightGetter);
	}

	function Recycler (initialHeightGetter, firstUnavailableIndexGetter, indexChangeListener, continuumProvider) {
		var providerIsFunction = typeof continuumProvider === "function";

		var recycler = this;

		var placeholder = makePlaceholder(0);

		var continuum = (providerIsFunction ? continuumProvider : provideContinuum)(function (index, contin) {
				return initialHeightGetter.call(recycler, index, recycler);
			});

		this._fence = new Fence(0, 0, 0, 0);

		this._placeholders = null;
		this._placeholders = new Snake(null, null);
		this._placeholders.addHead().body = placeholder;

		this._available = NumberList.prototype.provide();

		this._continuumInterface = null;
		this._continuumInterface = new ContinuumInterface(continuum, firstUnavailableIndexGetter, indexChangeListener);

		this._solver = new Solver();

		this._process();
	}

	Recycler.prototype.cull = function () {
		this._process(DESTRUCTIVE);
	};

	Recycler.prototype.truncate = function (capacity) {
		var interface = this._continuumInterface;
		var amount = 0|interface.getDiscreteCount();
		var limit = 0|capacity;
		var index = 0;
		var clamp = 0|(amount > limit);

		if (!arguments.length) {
			limit = amount;
			clamp = 0|true;
		}

		if (clamp) {
			this._migrate(limit);
			interface.trim(limit);
			return 0|true;
		} else {
			return 0|false;
		}
	};

	Recycler.prototype._migrate = function (limit) {
		var interface = this._continuumInterface;
		var alpha = this.getLowestIndex();
		var omega = this.getHighestIndex();
		var inUse = 1 + omega;
		var count = inUse - alpha;
		var lower = limit - count;
		var placeholders = this._placeholders;
		var available = this._available;
		var solver = this._solver;

		if (lower < 0) {
			this.reposition(0);
			solver.solve(DESTRUCTIVE, interface, 0, limit - 1, alpha, omega, placeholders, available, this);
		} else if (inUse > limit) {
			this.reposition(interface.getElevation(lower));
			solver.solve(DESTRUCTIVE, interface, lower, count - 1, alpha, omega, placeholders, available, this);
		}
	};

	Recycler.prototype.getLowestIndex = function () {
		var snake = this._placeholders.getHead();
		return snake ? snake.body.getOuterIndex() : -1;
	};

	Recycler.prototype.getHighestIndex = function () {
		var snake = this._placeholders.getTail();
		return snake ? snake.body.getOuterIndex() : -2;
	};

	Recycler.prototype.adjustHeightAtIndex = function (index, delta) {
		return this._continuumInterface.adjustHeight.apply(this._continuumInterface, arguments);
	};

	Recycler.prototype.setHeightAtIndex = function (index, height) {
		var result = this._continuumInterface.setHeight.apply(this._continuumInterface, arguments),
			at = 0|index,
			interface = this._continuumInterface,
			snake = this._placeholders.getHead(),
			outer = 0;

		while (snake && at > snake.body.getOuterIndex()) {
			snake = snake.getTail();
		}

		while (snake = (snake && snake.getTail())) {
			outer = snake.body.getOuterIndex();
			interface.notify(snake.body.getInnerIndex(), outer, outer, this);
		}

		return result;
	};

	Recycler.prototype.getHeightAtIndex = function (index) {
		return this._continuumInterface.getHeight.apply(this._continuumInterface, arguments);

	};

	Recycler.prototype.getElevationAtIndex = function (index) {
		return this._continuumInterface.getElevation.apply(this._continuumInterface, arguments);

	};

	Recycler.prototype.isElevationKnownAtIndex = function (index) {
		return this._continuumInterface.isElevationKnown.apply(this._continuumInterface, arguments);

	};

	Recycler.prototype.isHeightKnownAtIndex = function (index) {
		return this._continuumInterface.isHeightKnown.apply(this._continuumInterface, arguments);
	};

	Recycler.prototype.getFramePlacement = function () {
		return this._fence.getPlacement()
	};

	Recycler.prototype.getFrameDimension = function () {
		return this._fence.getDimension();
	};

	Recycler.prototype.getFrameLowerBound = function () {
		return this._fence.getLower();
	};

	Recycler.prototype.getFrameUpperBound = function () {
		return this._fence.getUpper();
	};

	Recycler.prototype.repositionFrame = function (position) {
		if (this._fence.reposition.apply(this._fence, arguments)) {
			this._process(NONDESTRUCTIVE);
		}
		return this;
	};

	Recycler.prototype.translateFrame = function (change) {
		if (this._fence.translate.apply(this._fence, arguments)) {
			this._process(NONDESTRUCTIVE);
		}
		return this;
	};

	Recycler.prototype.resizeFrame = function (size) {
		if (this._fence.resize.apply(this._fence, arguments)) {
			this._process(NONDESTRUCTIVE);
		}
		return this;
	};

	Recycler.prototype.adjustFrame = function (grow) {
		if (this._fence.adjust.apply(this._fence, arguments)) {
			this._process(NONDESTRUCTIVE);
		}
		return this;
	};

	Recycler.prototype.repadFrame = function (ahead, behind) {
		if (this._fence.repad.apply(this._fence, arguments)) {
			this._process(NONDESTRUCTIVE);
		}
		return this;
	};

	Recycler.prototype.setFrame = function (position, size, above, below) {
		var fence = this._fence;
		var process = 0;

		process = fence.reposition(position) || process;
		process = fence.resize(size) || process;
		process = fence.repad(above, below) || process;

		if (process) {
			this._process(NONDESTRUCTIVE);
		}

		return this;
	};

	Recycler.prototype._process = function (destructive) {
		var fence = this._fence;
		var interface = this._continuumInterface;
		var lower = 0|interface.getIndexAtElevation(+fence.getLower() || 0);
		var upper = 0|interface.getIndexAtElevation(+fence.getUpper() || 0);
		var placeholders = this._placeholders;
		var available = this._available;
		var alpha = this.getLowestIndex();
		var omega = this.getHighestIndex();
		var solver = this._solver;

		if (lower < 0) {
			lower = 0;
		}

		if (upper < 0) {
			upper = -1 + (0|interface.getDiscreteCount());
		}

		return solver.solve(destructive, interface, lower, upper, alpha, omega, placeholders, available, this);
	};



	function ContiguousRecycler (heightGetter, unavailableIndexGetter, changeListener, continuumProvider) {
		var cache = [];

		Recycler.call(this, heightGetter, unavailableIndexGetter, function (inner, young, old, recycler) {
			var maxIndex = cache.length - 1;
			var swap = -1;

			if (young < 0) {
				swap = cache[maxIndex];
				cache[inner] = young;
				if (maxIndex > inner) {
					changeListener.call(this, maxIndex, -1, swap, recycler);
					changeListener.call(this, inner, swap, old, recycler);
				}
				cache.pop();
			} else {
				if (maxIndex < inner) {
					cache.push(young);
				}
				changeListener.apply(this, arguments);
			}

		}, continuumProvider);
	}



	ContiguousRecycler.prototype = new Recycler(function (index) {
		return 44;
	}, function (request) {
		return -1;
	}, function (inner, young, old, recycler) {
	}, null);

	ContiguousRecycler.prototype.SparseRecycler = Recycler;

	scope.Recycler = ContiguousRecycler;

} (window));
</script>


