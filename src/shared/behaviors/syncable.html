<link rel="import" href="../js/storage.html"/>
<link rel="import" href="../js/datautils.html"/>
<link rel="import" href="../js/ajax.html"/>
<link rel="import" href="../behaviors/domgettable.html"/>
<link rel="import" href="../behaviors/falsifiable.html"/>
<script>
/**
 * @license
 * Copyright (c) 2015 MediaMath Inc. All rights reserved.
 * This code may only be used under the BSD style license found at http://mediamath.github.io/strand/LICENSE.txt

*/
(function(scope) {

	var DataUtils = StrandLib.DataUtils;
	var Storage = StrandLib.Storage;
	var Ajax = StrandLib.Ajax;

	var __csrf;

	function _getParamBase(obj) {
		obj = obj || {};
		return {
			params: obj.queryparam || [],
			urlParams: obj.urlparam || [],
			headers: obj.header || []
		};
	}

	// function _copy() {
	// 	var args = _clone(arguments);
	// 	var init = args.length > 1 ? args.shift() : {};
	// 	return args.reduce(function(prev, cur) {
	// 		if (_isType(cur,"object")) {
	// 			for(var i in cur) {
	// 				prev[i] = cur[i];
	// 			}
	// 		}
	// 		return prev;
	// 	}, init);
	// }

	var Syncable = {
		properties: {
			_csrf: {
				type:Object,
				value: function() {
					var csrf = new Storage("csrf","localStorage");
					__csrf = csrf.value;
					return csrf;
				}
			},
			_globals: {
				type:Object,
				value: function() {
					var globals = new Storage("globals","localStorage");
					if (globals.value === null) globals.value = {};
					return globals;
				}
			},

			_ajax: {
				type:Object,
				value: function() {
					return new Ajax(this.options);
				}
			},

			endpoint:{
				type:String,
				value:"/"
			},

			auto:{
				type:Boolean,
				value:true,
			},
			autoDebounce:{
				type:Number,
				value:200
			},

			options:{
				type:Object,
				value:function() {
					return {
						contentType:"application/x-www-form-urlencoded",
						timeout:10000,
						withCredentials:false,
						concurrency:4
					};
				}
			},

			data: {
				type:Object,
				value: function() {
					return {};
				},
				observe:"_dataChanged"
			},

			saveResponse: {
				type:Boolean,
				value:true
			},

			apiMarshaller:{
				type:Object,
				value:function() {
					return {
						noop:function(o) {return o;}
					};
				}
			},

			responseMarshaller: {
				type:String,
				value:"noop"
			},

			requestMarshaller: {
				type:String,
				value:"noop"
			},

			cacheGlobals: {
				type:Boolean,
				value:false,
			},

			cacheCsrf:{
				type:Boolean,
				value:false
			},
			csrfHeader:{
				type:String,
				value:"X-CSRF-Token"
			},
			csrfToken:{
				type:String,
				value: function() { return __csrf; }
			},

			cacheBuster: {
				type:Boolean,
				value:true,
			},

			inputParams:{
				type:Object,
				value:_getParamBase,
			},
			outputParams:{
				type:Object,
				value:_getParamBase,
			}
		},

		get: function(data, options) {
			return this.sync(Ajax.GET, data, options);
		},

		post: function(data, options) {
			return this.sync(Ajax.POST, data, options);
		},

		put: function(data, options) {
			return this.sync(Ajax.PUT, data, options);
		},

		delete: function (data, options) {
			return this.sync(Ajax.DELETE, data, options);
		},

		sync: function(method, data, options) {
			method = method || Ajax.GET;
			data = this.apiMarshaller[this.requestMarshaller]( data || this.body );

			var configOpts = this._getDomConfig(method, this.domObject);

			options = DataUtils.copy({method:method, url:this.endpoint}, options, configOpts, this.options);

			this._getCacheBuster(this.cacheBuster, options.params);
			this._setCSRFHeader(method, options.headers);

			var promise = this._ajax.exec( data, options );
			promise.then(this._handleResult, this._handleError);

			return promise;
		},

		_getDomConfig: function(method, domObject) {
			var domConfig = method === Ajax.GET ? this.domObject["input-params"] : this.domObject["output-params"];
			domConfig = _getParamBase(domConfig) || _getParamBase();

			return {
				headers: domConfig.headers.map(DataUtils.nodeToParam),
				params: domConfig.params.map(DataUtils.nodeToParam),
				urlParams: domConfig.urlParams.map(DataUtils.nodeInnerValue)
			};
		},

		domObjectChanged: function(domObject) {
			if (this.auto && this.auto !== "save") {
				this.debounce("dom", this.get, this.autoDebounce);
			}
		},

		_dataChanged:function(oldData, newData) {
			if (this.auto && this.auto !== "load") {
				this.debounce("dom", this.post, this.autoDebounce);
			}
		},

		_getCacheBuster: function(cacheBuster, queryParams) {
			if (this.cacheBuster) {
				queryParams = queryParams || [];

				var name = "nocache";
				if (typeof this.cacheBuster === "string" && this.cacheBuster.length > 0) {
					name = this.cacheBuster;
				}
				queryParams.push({
					name: name,
					value: Date.now()
				});
			}
		},

		_getCSRFHeader: function(result) {

			if (this.csrf && result && result.instance) {
				var ajax =  result.instance;
				var hasHeader = ajax.xhr.getAllResponseHeaders().indexOf(this.csrfHeader) !== -1;
				if (hasHeader) {
					var csrf = ajax.xhr.getResponseHeader(this.csrfHeader);
					__csrf = csrf;
					this.csrfToken = csrf;
					if (this.cacheCsrf) {
						this._csrf.value = csrf;
					}
				}
			}
		},

		_setCSRFHeader: function(method, headers) {
			if (this.csrf && __csrf) {
				var csrf = DataUtils.param(this.csrfHeader, __csrf );
				if (method === Ajax.GET) {
					headers.push(csrf);
				} else {
					headers.push(csrf);
				}
			}
		},

		_handleResult: function(result) {

			this._getCSRFHeader(result);
			this.fire("data-ready",result);

			if (this.saveResponse) {
				this.set("data", this.apiMarshaller[this.requestMarshaller]( this.result.response ));
			}
		},

		_handleError: function(error) {
			this.fire("data-error",error);
		},

		setGlobal: function(key, value) {
			this._globals.set(key,value);
		},

		getGlobal: function(key) {
			return this._globals.get(key);
		}
	};
	scope.Syncable = [
		scope.DomGettable,
		scope.Falsifiable,
		Syncable,
	];
}(window.StrandTraits = window.StrandTraits || {}));

</script>
